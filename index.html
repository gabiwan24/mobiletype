<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Typo Voice Physics</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; touch-action:none; }

    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const { Engine, Render, Runner, World, Bodies, Body, Composite, Common, Events, Vertices, Query } = Matter;

    // poly-decomp verbinden
    if (window.decomp && Common && Common.setDecomp) Common.setDecomp(window.decomp);

    // ---------- Canvas & Engine (CSS-Pixel 1:1) ----------
    const canvas = document.getElementById('world');
    const engine = Engine.create({
      enableSleeping: true
    });
    // beruhigtere Solver-Iterationen
    engine.positionIterations = 8;
    engine.velocityIterations = 8;
    engine.constraintIterations = 2;
    engine.world.gravity.y = 1;

    const render = Render.create({
      canvas, engine,
      options: { width: 0, height: 0, wireframes: false, background: "#fafafa", pixelRatio: 1 }
    });

    function resize() {
      const w = document.documentElement.clientWidth;
      const h = document.documentElement.clientHeight;
      if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
      render.options.width = w; render.options.height = h;
      render.canvas.style.width = w + "px"; render.canvas.style.height = h + "px";
      buildWalls(); placeMic();
    }
    window.addEventListener('resize', resize);
    Render.run(render); Runner.run(Runner.create(), engine);
    resize();

    // ---------- Unsichtbare Wände (Ränder) ----------
    const WALL_THICK = 60;
    let walls = null;
    function buildWalls() {
      if (walls) World.remove(engine.world, walls);
      const w = render.options.width, h = render.options.height, t = WALL_THICK;
      walls = Composite.create();
      const stat = { isStatic: true, friction: 1, restitution: 0.02, render: { visible: false } };
      Composite.add(walls, [
        Bodies.rectangle(w/2, h + t/2, w, t, stat), // Boden
        Bodies.rectangle(w/2, -t/2, w, t, stat),    // Decke
        Bodies.rectangle(-t/2, h/2, t, h, stat),    // links
        Bodies.rectangle(w + t/2, h/2, t, h, stat)  // rechts
      ]);
      World.add(engine.world, walls);
    }

    // ---------- Mic-Button als Collider ----------
    const MIC_R = 120; // Radius (Ø 240)
    let micBody = null;
    function placeMic() {
      if (micBody) World.remove(engine.world, micBody);
      const w = render.options.width, h = render.options.height;
      micBody = Bodies.circle(w/2, h - MIC_R - 20, MIC_R, {
        isStatic: true, friction: 1, frictionStatic: 1, restitution: 0.05, render: { visible: false }
      });
      World.add(engine.world, micBody);
    }

    // ---------- Font laden ----------
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf"; // <- anpassen
    let fontOT = null, canvasFontReady = false;

    function loadOTFont(url) { return new Promise((res, rej)=> opentype.load(url, (e,f)=> e?rej(e):res(f))); }
    (async () => {
      try { fontOT = await loadOTFont(LOCAL_FONT_URL); console.log("opentype Font ✔"); }
      catch(e){ console.error("Font-Load fail:", e); }
    })();
    (async () => {
      try { await Promise.race([document.fonts.load('700 120px "MontserratVar"'), new Promise(r=>setTimeout(r,1200))]); } catch{}
      try { await document.fonts.ready; } catch{}
      canvasFontReady = true;
    })();

    // ---------- Kurven-Sampling + Simplify ----------
    function quadAt(p0, p1, p2, t){ return { x:(1-t)*(1-t)*p0.x+2*(1-t)*t*p1.x+t*t*p2.x, y:(1-t)*(1-t)*p0.y+2*(1-t)*t*p1.y+t*t*p2.y }; }
    function cubicAt(p0,p1,p2,p3,t){ const mt=1-t; return { x: mt*mt*mt*p0.x+3*mt*mt*t*p1.x+3*mt*t*t*p2.x+t*t*t*p3.x, y: mt*mt*mt*p0.y+3*mt*mt*t*p1.y+3*mt*t*t*p2.y+t*t*t*p3.y }; }
    function pointLineDistance(p,a,b){ const A=p.x-a.x,B=p.y-a.y,C=b.x-a.x,D=b.y-a.y; const dot=A*C+B*D,len=C*C+D*D||1; let t=dot/len; t=Math.max(0,Math.min(1,t)); const x=a.x+t*C,y=a.y+t*D; return Math.hypot(p.x-x,p.y-y); }
    function rdp(points, eps){ if(points.length<3) return points.slice(); let idx=-1,max=-1; for(let i=1;i<points.length-1;i++){ const d=pointLineDistance(points[i],points[0],points[points.length-1]); if(d>max){max=d;idx=i;} } if(max>eps){ const a=rdp(points.slice(0,idx+1),eps), b=rdp(points.slice(idx),eps); return a.slice(0,-1).concat(b);} return [points[0],points[points.length-1]];}
    function pathToPolygons(path){
      const polys=[]; let cur=[]; let last={x:0,y:0}; const STEP_Q=10, STEP_C=16;
      path.commands.forEach(cmd=>{
        if(cmd.type==="M"){ if(cur.length){polys.push(cur); cur=[];} last={x:cmd.x,y:-cmd.y}; cur.push(last); }
        else if(cmd.type==="L"){ const p={x:cmd.x,y:-cmd.y}; cur.push(p); last=p; }
        else if(cmd.type==="Q"){ const cp={x:cmd.x1,y:-cmd.y1}, p2={x:cmd.x,y:-cmd.y}; for(let i=1;i<=STEP_Q;i++) cur.push(quadAt(last,cp,p2,i/STEP_Q)); last=p2; }
        else if(cmd.type==="C"){ const c1={x:cmd.x1,y:-cmd.y1}, c2={x:cmd.x2,y:-cmd.y2}, p3={x:cmd.x,y:-cmd.y}; for(let i=1;i<=STEP_C;i++) cur.push(cubicAt(last,c1,c2,p3,i/STEP_C)); last=p3; }
        else if(cmd.type==="Z"){ if(cur.length){polys.push(cur); cur=[];} }
      });
      if(cur.length) polys.push(cur);
      const EPS=0.8; return polys.map(poly=> poly.length>3 ? rdp(poly,EPS):poly);
    }

    // ---------- Lautstärke → Schriftschnitt ----------
    let isRecording = false;
    let currentWord = "";         // live-Rendering text
    let currentWght = 400;        // 100..800
    let maxVolume = 0;            // Peak über die Aufnahme
    let audioCtx = null, analyser = null, mediaStream = null;

    function startAudioMeter() {
      return navigator.mediaDevices.getUserMedia({ audio: true }).then(stream=>{
        mediaStream = stream;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        src.connect(analyser);
        tickVolume();
      });
    }
    function stopAudioMeter() {
      if (mediaStream) { mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
      if (audioCtx) { audioCtx.close().catch(()=>{}); audioCtx=null; }
      analyser = null;
    }
    function tickVolume() {
      if (!analyser) return;
      const buf = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(buf);
      // RMS
      let sum = 0; for (let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; }
      const rms = Math.sqrt(sum / buf.length); // ~0..1
      maxVolume = Math.max(maxVolume, rms);
      const v = Math.min(1, rms * 8); // Verstärkung
      const wght = Math.round(100 + (800-100) * v);
      currentWght = Math.max(100, Math.min(800, wght));
      requestAnimationFrame(tickVolume);
    }

    // ---------- Speech Recognition (Chromium) ----------
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    function startSpeech() {
      if (!SR) { alert("Spracherkennung nicht unterstützt."); return; }
      if (isRecording) return;
      recognition = new SR();
      recognition.lang = "de-DE";
      recognition.interimResults = true;
      recognition.continuous = true;

      currentWord = ""; maxVolume = 0; currentWght = 400;

      recognition.onresult = (e) => {
        let finalText = "";
        for (let i=e.resultIndex; i<e.results.length; i++){
          const res = e.results[i];
          if (res.isFinal) finalText += res[0].transcript;
          else currentWord = res[0].transcript; // live anzeigen
        }
        if (finalText.trim()) currentWord = finalText.trim();
      };
      recognition.onend = () => { isRecording = false; finalizeWord(); };
      recognition.onerror = (ev) => { console.error(ev); isRecording = false; finalizeWord(); };

      startAudioMeter().then(()=>{
        try { recognition.start(); isRecording = true; } catch(e){ console.error(e); isRecording=false; }
      }).catch(err=>{
        console.error(err);
        // zur Not ohne Speech, aber mit AudioMeter?
      });
    }
    function stopSpeech() {
      try { recognition && recognition.stop(); } catch{}
      stopAudioMeter();
    }

    // ---------- Wort → Physik (zerfällt in Buchstaben) ----------
    const LETTER_TTL_MS = 30000;
    const letterGroups = []; // Verwaltung zum Aufräumen

    function measureWord(word, size) {
      const scale = size / fontOT.unitsPerEm;
      const glyphs = fontOT.stringToGlyphs(word);
      let width = 0;
      for (let i=0;i<glyphs.length;i++){
        const g = glyphs[i];
        width += g.advanceWidth * scale;
        if (i < glyphs.length - 1) width += fontOT.getKerningValue(g, glyphs[i+1]) * scale;
      }
      return { glyphs, width, scale };
    }

    function spawnFallingWord(word, size, wght, volumePeak) {
      if (!fontOT) return;
      word = word.trim(); if (!word) return;

      const { glyphs, width } = measureWord(word, size);
      const w = render.options.width, h = render.options.height;
      const inset = WALL_THICK + 8;
      const spawnX = Math.max(inset + width/2, Math.min(w - inset - width/2, w/2));
      const spawnY = Math.max(inset + size/2, Math.min(h - inset - size/2 - (MIC_R + 24), h/2));

      const letters = [];
      let penX = -width/2;
      const chars = Array.from(word);
      let charIdx = 0;

      for (let i=0;i<glyphs.length;i++){
        const g = glyphs[i];
        const path = g.getPath(0, 0, size);
        const polys = pathToPolygons(path);
        // Advance inkl. Kerning
        const scale = size / fontOT.unitsPerEm;
        const adv = (g.advanceWidth * scale) + (i<glyphs.length-1 ? fontOT.getKerningValue(g, glyphs[i+1]) * scale : 0);

        if (polys.length){
          const shifted = polys.map(poly => poly.map(p => ({ x: p.x + penX, y: p.y })));
          const body = Bodies.fromVertices(spawnX, spawnY, shifted, {
            friction: 0.9,
            frictionStatic: 1.0,
            frictionAir: 0.03,     // beruhigt
            restitution: 0.05,     // wenig Bounciness
            render: { visible: false },
            sleepThreshold: 30
          }, true);
          if (body){
            const ch = chars[charIdx] || " ";
            body.label = "char:" + ch;
            // Masse/Dichte: Grundfläche * Zufall * Lautstärke
            try {
              const flat = shifted.flat();
              const hull = Vertices.hull(flat);
              const area = Math.abs(Vertices.area(hull));
              const loudFactor = 0.7 + 0.6 * Math.min(1, volumePeak * 6); // 0.7..1.3
              const randFactor  = 0.7 + Math.random()*0.6;                // 0.7..1.3
              const mass = Math.max(1, (area/1500) * loudFactor * randFactor);
              Body.setMass(body, mass);
            } catch {}
            // unterschiedliche Starrotation
            Body.setAngularVelocity(body, (Math.random()*2-1) * 0.3);
            letters.push({ body, char: ch, size, wght });
            Composite.add(engine.world, body);
          }
          charIdx++;
        }
        penX += adv;
      }

      // Auto-Remove
      const group = { letters };
      letterGroups.push(group);
      setTimeout(()=>{
        for (const L of group.letters) Composite.remove(engine.world, L.body);
        const idx = letterGroups.indexOf(group); if (idx>=0) letterGroups.splice(idx,1);
      }, LETTER_TTL_MS);
    }

    function finalizeWord() {
      stopAudioMeter();
      const word = (currentWord || "").trim();
      if (!word) return;
      // letzten wght nehmen (während Aufnahme dynamisch)
      const size = 100;
      const wght = currentWght;
      const peak = maxVolume;
      currentWord = ""; // live-anzeige beenden
      spawnFallingWord(word, size, wght, peak);
    }

    // ---------- Rendering ----------
    Events.on(render, "afterRender", () => {
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      // 1) Live-Wort als Zeile in der Mitte (solange aufgenommen wird oder interim da ist)
      if (canvasFontReady && (isRecording || currentWord)) {
        const w = render.options.width, h = render.options.height;
        const inset = WALL_THICK + 8;
        ctx.font = `${currentWght} ${120}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        let text = currentWord || "";
        // Breite messen & clampen in die sichere Zone
        const metrics = ctx.measureText(text);
        const textWidth = metrics.width;
        let x = Math.max(inset + textWidth/2, Math.min(w - inset - textWidth/2, w/2));
        let y = Math.max(inset + 120, Math.min(h - inset - (MIC_R + 24), h/2));
        ctx.fillStyle = "#222";
        ctx.shadowColor = "rgba(0,0,0,0.20)"; ctx.shadowBlur = 6; ctx.shadowOffsetY = 1;
        ctx.fillText(text, x, y);
      }

      // 2) Physische Buchstaben zeichnen
      if (canvasFontReady) {
        ctx.shadowColor = "rgba(0,0,0,0.20)"; ctx.shadowBlur = 6; ctx.shadowOffsetY = 1;
        for (const group of letterGroups) {
          for (const L of group.letters) {
            const { body, char, size, wght } = L;
            const { x, y } = body.position;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(body.angle);
            ctx.font = `${wght} ${size}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial`;
            ctx.fillStyle = "#222";
            ctx.fillText(char, 0, size*0.35);
            ctx.restore();
          }
        }
      }

      // 3) Mic-Button schwarz, groß, klickbar
      if (micBody) {
        const { x, y } = micBody.position;
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath(); ctx.arc(0, 0, MIC_R, 0, Math.PI*2); ctx.closePath();
        ctx.fillStyle = "#000"; ctx.fill();
        ctx.font = `bold ${MIC_R}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText("🎤", 0, 4);
        ctx.restore();
      }

      ctx.restore();
    });

    // ---------- Pointer: press & hold auf Mic-Kreis ----------
    function hitMic(evt) {
      if (!micBody) return false;
      const rect = canvas.getBoundingClientRect();
      const cx = (evt.clientX ?? (evt.touches && evt.touches[0]?.clientX)) - rect.left;
      const cy = (evt.clientY ?? (evt.touches && evt.touches[0]?.clientY)) - rect.top;
      const dx = cx - micBody.position.x, dy = cy - micBody.position.y;
      return (dx*dx + dy*dy) <= (MIC_R*MIC_R);
    }

    canvas.addEventListener('pointerdown', (e)=>{
      if (hitMic(e)) {
        e.preventDefault(); canvas.setPointerCapture?.(e.pointerId);
        startSpeech();
      }
    });
    canvas.addEventListener('pointerup', (e)=>{
      if (isRecording) { e.preventDefault(); stopSpeech(); }
    });
    canvas.addEventListener('pointercancel', ()=> { if (isRecording) stopSpeech(); });
    window.addEventListener('blur', ()=> { if (isRecording) stopSpeech(); });

  </script>
</body>
</html>

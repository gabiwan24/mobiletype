<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Gyro Typo – Voice</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; }

    /* Lokale Schrift – passe den Pfad an dein Repo an! */
    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <!-- poly-decomp (für Polygon-Zerlegung) -->
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <!-- opentype.js -->
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const {
      Engine, Render, Runner, World, Bodies, Body, Composite,
      Common, Events, Vertices, Query, Constraint
    } = Matter;

    // poly-decomp an Matter binden
    if (window.decomp && Common && Common.setDecomp) {
      Common.setDecomp(window.decomp);
    }

    // ---------- Canvas/Engine ----------
    const canvas = document.getElementById("world");
    const engine = Engine.create();
    engine.world.gravity.y = 1; // Basisgravitation; Physik immer aktiv

    const render = Render.create({
      canvas,
      engine,
      options: {
        width: 0, height: 0, // setzen wir gleich
        wireframes: false,
        background: "#fafafa",
        pixelRatio: 1
      }
    });

    function sizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const cssW = document.documentElement.clientWidth;
      const cssH = document.documentElement.clientHeight;
      const pxW = Math.floor(cssW * dpr), pxH = Math.floor(cssH * dpr);
      if (canvas.width !== pxW || canvas.height !== pxH) {
        canvas.width = pxW; canvas.height = pxH;
      }
      render.options.width = cssW;
      render.options.height = cssH;
      render.canvas.style.width = cssW + "px";
      render.canvas.style.height = cssH + "px";
    }
    sizeCanvasToDisplaySize();
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // ---------- Unsichtbare Wände (volle Bildschirmränder) ----------
    const WALL_THICK = 50;
    let walls = null;
    function buildWalls() {
      if (walls) World.remove(engine.world, walls);
      const w = render.options.width, h = render.options.height, t = WALL_THICK;
      walls = Composite.create();
      const opts = { isStatic: true, render: { visible: false } }; // unsichtbar!
      Composite.add(walls, [
        Bodies.rectangle(w/2, h + t/2, w, t, opts), // Boden
        Bodies.rectangle(w/2, -t/2, w, t, opts),    // Decke
        Bodies.rectangle(-t/2, h/2, t, h, opts),    // links
        Bodies.rectangle(w + t/2, h/2, t, h, opts)  // rechts
      ]);
      World.add(engine.world, walls);
    }

    // ---------- Mic-Button als physischer Collider ----------
    const MIC_R = 36; // px
    let micBody = null;
    function placeMic() {
      if (micBody) World.remove(engine.world, micBody);
      const w = render.options.width, h = render.options.height;
      const y = h - MIC_R - 14; // etwas Abstand vom unteren Rand
      micBody = Bodies.circle(w/2, y, MIC_R, {
        isStatic: true,
        restitution: 0.2,
        friction: 0.9,
        frictionStatic: 1.0,
        render: { fillStyle: "transparent" } // wir malen selbst
      });
      World.add(engine.world, micBody);
    }

    // ---------- Responsiveness ----------
    function onResize() {
      sizeCanvasToDisplaySize();
      buildWalls();
      placeMic();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // ---------- Font laden ----------
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf"; // <- passe an
    let fontOT = null;
    let canvasFontReady = false;

    function loadOTFont(url) {
      return new Promise((resolve, reject) =>
        opentype.load(url, (err, f) => err ? reject(err) : resolve(f))
      );
    }

    (async () => {
      try {
        fontOT = await loadOTFont(LOCAL_FONT_URL);
        console.log("opentype Font geladen ✔️");
      } catch (e) {
        console.error("Font konnte nicht geladen werden:", e);
      }
    })();

    (async () => {
      try {
        await Promise.race([
          document.fonts.load('600 100px "MontserratVar"'),
          new Promise(r=>setTimeout(r, 1500))
        ]);
      } catch {}
      try { await document.fonts.ready; } catch {}
      canvasFontReady = true;
    })();

    // ---------- Pfad-Sampling + Vereinfachung ----------
    function quadAt(p0, p1, p2, t) {
      const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
      const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
      return {x,y};
    }
    function cubicAt(p0,p1,p2,p3,t){
      const mt = 1-t;
      const x = mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x;
      const y = mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y;
      return {x,y};
    }
    function pointLineDistance(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A*C + B*D;
      const lenSq = C*C + D*D || 1;
      let t = dot / lenSq; t = Math.max(0, Math.min(1, t));
      const x = a.x + t*C, y = a.y + t*D;
      return Math.hypot(p.x - x, p.y - y);
    }
    function rdp(points, epsilon) {
      if (points.length < 3) return points.slice();
      let idx = -1, maxDist = -1;
      for (let i=1;i<points.length-1;i++){
        const d = pointLineDistance(points[i], points[0], points[points.length-1]);
        if (d > maxDist) { idx = i; maxDist = d; }
      }
      if (maxDist > epsilon) {
        const left = rdp(points.slice(0, idx+1), epsilon);
        const right = rdp(points.slice(idx), epsilon);
        return left.slice(0, -1).concat(right);
      }
      return [points[0], points[points.length-1]];
    }
    function pathToPolygons(path) {
      const polys = [];
      let cur = [];
      let last = {x:0,y:0};
      const STEP_Q = 12, STEP_C = 18;

      path.commands.forEach(cmd => {
        if (cmd.type === "M") {
          if (cur.length) { polys.push(cur); cur = []; }
          last = { x: cmd.x, y: -cmd.y };
          cur.push(last);
        } else if (cmd.type === "L") {
          const p = { x: cmd.x, y: -cmd.y };
          cur.push(p); last = p;
        } else if (cmd.type === "Q") {
          const cp = { x: cmd.x1, y: -cmd.y1 };
          const p2 = { x: cmd.x,  y: -cmd.y };
          for (let i=1;i<=STEP_Q;i++) cur.push(quadAt(last, cp, p2, i/STEP_Q));
          last = p2;
        } else if (cmd.type === "C") {
          const c1 = { x: cmd.x1, y: -cmd.y1 };
          const c2 = { x: cmd.x2, y: -cmd.y2 };
          const p3 = { x: cmd.x,  y: -cmd.y };
          for (let i=1;i<=STEP_C;i++) cur.push(cubicAt(last, c1, c2, p3, i/STEP_C));
          last = p3;
        } else if (cmd.type === "Z") {
          if (cur.length) { polys.push(cur); cur = []; }
        }
      });
      if (cur.length) polys.push(cur);

      const EPS = 0.8; // px
      return polys.map(poly => (poly.length > 3 ? rdp(poly, EPS) : poly));
    }

    // ---------- Wort-Spawn (Verbund + Sollbruchstellen) ----------
    const LETTER_TTL_MS = 30000;
    const words = []; // [{letters:[bodies], constraints:[c], size, born}]
    function measureWord(word, size) {
      const scale = size / fontOT.unitsPerEm;
      const glyphs = fontOT.stringToGlyphs(word);
      let width = 0;
      for (let i = 0; i < glyphs.length; i++) {
        const g = glyphs[i];
        width += g.advanceWidth * scale;
        if (i < glyphs.length - 1) {
          width += fontOT.getKerningValue(g, glyphs[i+1]) * scale;
        }
      }
      return { glyphs, width, scale };
    }
    function canSpawnRegion(region) {
      const bodies = Composite.allBodies(engine.world);
      const hits = Query.region(bodies, region);
      // Wenn der Bereich frei von echten (nicht Sensor) Bodies ist → OK
      return !hits.some(b => !b.isSensor);
    }
    function spawnWord(word) {
      if (!fontOT) return;
      word = word.trim();
      if (!word) return;

      const size = 84;              // Wort-Schriftgröße
      const gapTighten = -2;        // leichte Negativlaufweite (optisch kompakt)
      const { glyphs, width, scale } = measureWord(word, size);
      // Spawn-Ziel: Mitte clamped an Wände
      const w = render.options.width, h = render.options.height;
      const safeInset = WALL_THICK + 8;
      let spawnX = Math.max(safeInset + width/2, Math.min(w - safeInset - width/2, w/2));
      let spawnY = Math.max(safeInset + size/2, Math.min(h - safeInset - size/2 - (MIC_R+24), h/2));
      // Region-Check (breite Rechteck-Approx des Wortes)
      const region = {
        min: { x: spawnX - width/2 - 6, y: spawnY - size/1.4 - 6 },
        max: { x: spawnX + width/2 + 6, y: spawnY + size/1.8 + 6 }
      };
      if (!canSpawnRegion(region)) {
        // kein Platz → nicht weiterschreiben
        return;
      }

      // Für jedes Zeichen: Pfad → Polys → Body (mit Offsets)
      const letters = [];
      let penX = -width/2; // beginnen links, so dass die Wortmitte bei spawnX liegt
      for (let i = 0; i < glyphs.length; i++) {
        const g = glyphs[i];
        const path = g.getPath(0, 0, size);
        const polys = pathToPolygons(path);
        if (!polys.length) {
          // trotzdem Pen weiter
          const adv = (g.advanceWidth * scale) + (i<glyphs.length-1 ? fontOT.getKerningValue(g, glyphs[i+1]) * scale : 0) + gapTighten;
          penX += adv;
          continue;
        }
        // Body aus Vertices, an (spawnX + penX + shift, spawnY)
        const localShiftX = 0; // Glyphenpfad startet meist bei 0
        const shiftedPolys = polys.map(poly => poly.map(p => ({ x: p.x + penX + localShiftX, y: p.y })));
        const body = Bodies.fromVertices(spawnX, spawnY, shiftedPolys, {
          friction: 0.9, frictionStatic: 1.0, frictionAir: 0.01, restitution: 0.12,
          render: { fillStyle: "#00000000" }
        }, true);
        if (body) {
          letters.push(body);
        }
        // Pen vorrücken
        const adv = (g.advanceWidth * scale) + (i<glyphs.length-1 ? fontOT.getKerningValue(g, glyphs[i+1]) * scale : 0) + gapTighten;
        penX += adv;
      }
      if (!letters.length) return;

      // Verbinden: Constraints zwischen benachbarten Buchstaben (Sollbruchstellen)
      const constraints = [];
      for (let i = 0; i < letters.length - 1; i++) {
        const A = letters[i], B = letters[i+1];
        const dx = (B.position.x - A.position.x), dy = (B.position.y - A.position.y);
        const len = Math.hypot(dx, dy);
        const c = Constraint.create({
          bodyA: A, bodyB: B,
          pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 },
          length: Math.max(8, Math.min(24, len * 0.8)),
          stiffness: 0.7,
          damping: 0.02,
          render: { visible: false }
        });
        constraints.push(c);
      }

      // Gruppe in die Welt
      Composite.add(engine.world, letters);
      Composite.add(engine.world, constraints);

      // Auto-Remove nach 30s
      const born = performance.now();
      const rec = { letters, constraints, word, size, born };
      words.push(rec);
      setTimeout(() => {
        // entfernen
        for (const c of rec.constraints) Composite.remove(engine.world, c);
        for (const b of rec.letters) Composite.remove(engine.world, b);
        const idx = words.indexOf(rec);
        if (idx >= 0) words.splice(idx, 1);
      }, LETTER_TTL_MS);
    }

    // Constraint-Bruch (reißende Worte)
    Events.on(engine, "afterUpdate", () => {
      for (const rec of words) {
        for (let i = rec.constraints.length - 1; i >= 0; i--) {
          const c = rec.constraints[i];
          if (!c.bodyA || !c.bodyB) continue;
          const ax = c.bodyA.position.x + (c.pointA?.x || 0);
          const ay = c.bodyA.position.y + (c.pointA?.y || 0);
          const bx = c.bodyB.position.x + (c.pointB?.x || 0);
          const by = c.bodyB.position.y + (c.pointB?.y || 0);
          const dist = Math.hypot(bx - ax, by - ay);
          const breakLen = (c.length || 12) * 1.6; // wie viel Dehnung erlaubt
          if (dist > breakLen) {
            Composite.remove(engine.world, c);
            rec.constraints.splice(i, 1);
          }
        }
      }
    });

    // ---------- Rendering: Worte + Mic-Button ----------
    Events.on(render, "afterRender", () => {
      if (!canvasFontReady) return;
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic"; // bessere optische Lage
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 1;

      // alle Buchstaben aller Wörter zeichnen
      for (const rec of words) {
        for (const body of rec.letters) {
          const { x, y } = body.position;
          ctx.translate(x, y);
          ctx.rotate(body.angle);
          ctx.font = `700 ${rec.size}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
          ctx.fillStyle = "#222";
          // Body repräsentiert einen Buchstaben – wir brauchen das tatsächliche Zeichen nicht einzeln;
          // Stattdessen nutzen wir den ursprünglichen Pfad-Zeichen-Offset:
          // Einfachheitshalber zeichnen wir den nächsten bestpassenden Text über die Poly-Position:
          // Für saubere Buchstaben-zu-Body-Mapping müssten wir pro Body das Zeichen merken;
          // Hier speichern wir es pragmatisch im Label:
          const ch = body.label && body.label.startsWith("char:") ? body.label.slice(5) : null;
          if (ch) ctx.fillText(ch, 0, rec.size * 0.35);
          ctx.rotate(-body.angle);
          ctx.translate(-x, -y);
        }
      }

      // Mic-Button zeichnen (über der Szene)
      if (micBody) {
        const { x, y } = micBody.position;
        ctx.translate(x, y);
        // Kreis
        ctx.beginPath();
        ctx.arc(0, 0, MIC_R, 0, Math.PI*2);
        ctx.closePath();
        ctx.fillStyle = isRecording ? "#e74c3c" : "#ffffff";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.stroke();
        // Icon
        ctx.font = `bold ${MIC_R}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = isRecording ? "#fff" : "#333";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("🎤", 0, 1);
        ctx.translate(-x, -y);
      }

      ctx.restore();
    });

    // Damit im Rendering der richtige Buchstabe auftaucht, überschreiben wir spawnWord leicht:
    // Wir setzen 'label' = 'char:<zeichen>' beim Erzeugen des Bodies.
    const _spawnWord = spawnWord;
    spawnWord = function(word) {
      if (!fontOT) return;
      word = word.trim();
      if (!word) return;

      const size = 84;
      const gapTighten = -2;
      const { glyphs, width, scale } = measureWord(word, size);

      const w = render.options.width, h = render.options.height;
      const safeInset = WALL_THICK + 8;
      let spawnX = Math.max(safeInset + width/2, Math.min(w - safeInset - width/2, w/2));
      let spawnY = Math.max(safeInset + size/2, Math.min(h - safeInset - size/2 - (MIC_R+24), h/2));
      const region = {
        min: { x: spawnX - width/2 - 6, y: spawnY - size/1.4 - 6 },
        max: { x: spawnX + width/2 + 6, y: spawnY + size/1.8 + 6 }
      };
      if (!canSpawnRegion(region)) return;

      const letters = [];
      let penX = -width/2;
      let textChars = Array.from(word);
      let charIndex = 0;

      for (let i = 0; i < glyphs.length; i++) {
        const g = glyphs[i];
        const path = g.getPath(0, 0, size);
        const polys = pathToPolygons(path);
        const adv = (g.advanceWidth * scale) + (i<glyphs.length-1 ? fontOT.getKerningValue(g, glyphs[i+1]) * scale : 0) + gapTighten;

        if (polys.length) {
          const shiftedPolys = polys.map(poly => poly.map(p => ({ x: p.x + penX, y: p.y })));
          const body = Bodies.fromVertices(spawnX, spawnY, shiftedPolys, {
            friction: 0.9, frictionStatic: 1.0, frictionAir: 0.01, restitution: 0.12,
            render: { fillStyle: "#00000000" }
          }, true);
          if (body) {
            // Vermute das sichtbare Zeichen (fallback auf Leerzeichen)
            const ch = textChars[charIndex] || " ";
            body.label = "char:" + ch;
            letters.push(body);
            charIndex++;
          }
        }
        penX += adv;
      }
      if (!letters.length) return;

      const constraints = [];
      for (let i = 0; i < letters.length - 1; i++) {
        const A = letters[i], B = letters[i+1];
        const dx = (B.position.x - A.position.x), dy = (B.position.y - A.position.y);
        const len = Math.hypot(dx, dy);
        const c = Constraint.create({
          bodyA: A, bodyB: B,
          length: Math.max(8, Math.min(24, len * 0.8)),
          stiffness: 0.7,
          damping: 0.02,
          render: { visible: false }
        });
        constraints.push(c);
      }

      Composite.add(engine.world, letters);
      Composite.add(engine.world, constraints);

      const born = performance.now();
      const rec = { letters, constraints, word, size, born };
      words.push(rec);
      setTimeout(() => {
        for (const c of rec.constraints) Composite.remove(engine.world, c);
        for (const b of rec.letters) Composite.remove(engine.world, b);
        const idx = words.indexOf(rec);
        if (idx >= 0) words.splice(idx, 1);
      }, LETTER_TTL_MS);
    };

    // ---------- Web Speech: Push-to-Talk ----------
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;

    function pointerIsOnMic(evt) {
      if (!micBody) return false;
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left);
      const y = (evt.clientY - rect.top);
      const dx = x - micBody.position.x;
      const dy = y - micBody.position.y;
      return (dx*dx + dy*dy) <= (MIC_R*MIC_R);
    }

    function startRecording() {
      if (!SR) { alert("Spracherkennung wird von diesem Browser nicht unterstützt."); return; }
      if (isRecording) return;
      recognition = new SR();
      recognition.lang = "de-DE";
      recognition.interimResults = false;
      recognition.continuous = true;

      recognition.onresult = (e) => {
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const res = e.results[i];
          if (res.isFinal) {
            const text = (res[0].transcript || "").trim();
            if (text) {
              // Ganze Worte spawnen
              const wordsList = text.split(/\s+/);
              for (const w of wordsList) spawnWord(w);
            }
          }
        }
      };
      recognition.onend = () => { isRecording = false; };
      recognition.onerror = (ev) => { console.error(ev); isRecording = false; };

      try { recognition.start(); isRecording = true; }
      catch (e) { console.error(e); isRecording = false; }
    }

    function stopRecording() {
      if (recognition) {
        try { recognition.stop(); } catch {}
        recognition = null;
      }
      isRecording = false;
    }

    // Pointer-Events auf dem Canvas (Press & Hold auf Mic-Kreis)
    canvas.addEventListener('pointerdown', (e) => {
      if (pointerIsOnMic(e)) {
        e.preventDefault();
        startRecording();
      }
    });
    window.addEventListener('pointerup', (e) => {
      if (isRecording) stopRecording();
    });
    window.addEventListener('pointercancel', () => { if (isRecording) stopRecording(); });
    window.addEventListener('blur', () => { if (isRecording) stopRecording(); });

    // ---------- Fertig ----------
  </script>
</body>
</html>

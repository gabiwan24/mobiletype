<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Gyro Typo Playground</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; width:100vw; height:100vh; }
    #ui {
      position: fixed; inset:auto 0 0 0; display:flex; gap:8px;
      padding:10px; background:linear-gradient(to top, rgba(250,250,250,0.95), rgba(250,250,250,0.6));
      align-items:center; backdrop-filter:saturate(1.1) blur(6px);
    }
    #input { flex:1; font-size:16px; padding:10px 12px; border-radius:12px; border:1px solid #ddd; }
    #gyroBtn { padding:10px 12px; border-radius:12px; border:1px solid #ddd; background:#fff; }
    /* Canvas-Rendering-Font (für sichtbaren Text) – lokal aus deinem Repo */
    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900; /* Variable-Achse wght */
      font-style: normal;
      font-display: swap;
    }
    /* Fallback – nur fürs normale Canvas-Text-Rendering, falls @font-face blockt */
    .use-montserrat { font-family:"MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <div id="ui" class="use-montserrat">
    <input id="input" type="text" placeholder="Tippe hier einzelne Buchstaben…" inputmode="latin" />
    <button id="gyroBtn" type="button">Gyro aktivieren</button>
  </div>

  <!-- poly-decomp muss vor Matter fromVertices nutzbar sein -->
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <!-- opentype.js -->
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const { Engine, Render, Runner, World, Bodies, Vertices, Events, Body } = Matter;

    // ----- Canvas + Engine -----
    const canvas = document.getElementById("world");
    const engine = Engine.create();
    engine.world.gravity.y = 1; // Standard, wird durch Gyro überschrieben
    const render = Render.create({
      canvas,
      engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "#fafafa",
        pixelRatio: window.devicePixelRatio
      }
    });
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // Resize
    function resize() {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      // Wände anpassen: hier einfach neu erstellen (simpel)
      World.remove(engine.world, walls);
      makeWalls();
    }
    window.addEventListener("resize", resize);

    // ----- Wände -----
    let walls = null;
    function makeWalls() {
      const w = render.options.width;
      const h = render.options.height;
      const t = 50;
      walls = Matter.Composite.create();
      const wallBodies = [
        Bodies.rectangle(w/2, h + t/2, w, t, { isStatic: true }), // Boden
        Bodies.rectangle(w/2, -t/2, w, t, { isStatic: true }),     // Decke
        Bodies.rectangle(-t/2, h/2, t, h, { isStatic: true }),     // links
        Bodies.rectangle(w + t/2, h/2, t, h, { isStatic: true })   // rechts
      ];
      Matter.Composite.add(walls, wallBodies);
      World.add(engine.world, walls);
    }
    makeWalls();

    // ----- Font laden (lokal) mit Fallback -----
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf";
    const FALLBACK_TTF = "https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/montserrat/Montserrat-Regular.ttf";

    let font = null;
    function loadFont(url, onDone) {
      opentype.load(url, (err, f) => {
        onDone(err, f);
      });
    }
    loadFont(LOCAL_FONT_URL, (err, f) => {
      if (!err && f) {
        font = f;
        console.log("Font (lokal) geladen ✔️");
      } else {
        console.warn("Lokaler Font konnte nicht geladen werden, versuche Fallback:", err);
        loadFont(FALLBACK_TTF, (err2, f2) => {
          if (!err2 && f2) {
            font = f2;
            console.log("Fallback-Font geladen ✔️");
          } else {
            console.error("Kein Font verfügbar:", err2);
          }
        });
      }
    });

    // ----- Pfad → Polygone (mit Kurven-Approximation) -----
    // Wir sampeln Quadratic/Cubic-Bézierkurven, damit die Kontur schön der Schrift folgt.
    function lerp(a,b,t){ return a + (b-a)*t; }
    function quadAt(p0, p1, p2, t) {
      const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
      const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
      return {x,y};
    }
    function cubicAt(p0,p1,p2,p3,t){
      const mt = 1-t;
      const x = mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x;
      const y = mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y;
      return {x,y};
    }

    function pathToPolygons(path) {
      const polys = [];
      let cur = [];
      let last = {x:0,y:0};
      const STEP_Q = 12; // mehr = glatter
      const STEP_C = 18;

      path.commands.forEach(cmd => {
        if (cmd.type === "M") {
          if (cur.length) { polys.push(cur); cur = []; }
          last = { x: cmd.x, y: -cmd.y };
          cur.push(last);
        } else if (cmd.type === "L") {
          const p = { x: cmd.x, y: -cmd.y };
          cur.push(p);
          last = p;
        } else if (cmd.type === "Q") {
          const cp = { x: cmd.x1, y: -cmd.y1 };
          const p2 = { x: cmd.x,  y: -cmd.y  };
          for (let i = 1; i <= STEP_Q; i++) {
            const t = i/STEP_Q;
            cur.push(quadAt(last, cp, p2, t));
          }
          last = p2;
        } else if (cmd.type === "C") {
          const c1 = { x: cmd.x1, y: -cmd.y1 };
          const c2 = { x: cmd.x2, y: -cmd.y2 };
          const p3 = { x: cmd.x,  y: -cmd.y  };
          for (let i = 1; i <= STEP_C; i++) {
            const t = i/STEP_C;
            cur.push(cubicAt(last, c1, c2, p3, t));
          }
          last = p3;
        } else if (cmd.type === "Z") {
          if (cur.length) { polys.push(cur); cur = []; }
        }
      });
      if (cur.length) polys.push(cur);

      // Vereinfachen (Pixel-Toleranz 0.8), danach zurück
      return polys.map(poly => Vertices.simplify(poly, 0.8));
    }

    // ----- Buchstaben-Verwaltung -----
    const letters = [];
    const LETTER_TTL_MS = 30000;

    function spawnLetter(char) {
      if (!font) return;

      const size = 100; // sichtbare Schriftgröße UND für Kontur
      // opentype: Pfad für den Buchstaben
      const path = font.getPath(char, 0, 0, size);
      const polygons = pathToPolygons(path);
      if (!polygons.length) return;

      // Physik-Body aus Polygonen
      const body = Bodies.fromVertices(
        render.options.width / 2,
        Math.max(120, window.innerHeight * 0.2),
        polygons,
        {
          friction: 0.85,
          frictionStatic: 1.0,
          frictionAir: 0.01,
          restitution: 0.18,
          chamfer: 0,
          render: { fillStyle: "#00000000" } // wir zeichnen Text selbst
        },
        true
      );

      if (!body) return;

      // Masse ≈ Fläche des konvexen Hull (Annäherung)
      try {
        const area = Matter.Vertices.area(Matter.Vertices.hull(polygons.flat()));
        if (area && isFinite(area)) Body.setMass(body, Math.max(1, area / 1500));
      } catch {}

      World.add(engine.world, body);

      const rec = { body, char, size, born: performance.now() };
      letters.push(rec);

      // Auto-Remove
      setTimeout(() => {
        World.remove(engine.world, body);
        const idx = letters.indexOf(rec);
        if (idx >= 0) letters.splice(idx, 1);
      }, LETTER_TTL_MS);
    }

    // ----- Eingabe (einzelne Buchstaben) -----
    const input = document.getElementById("input");
    input.addEventListener("beforeinput", (e) => {
      // Nur einzelne Zeichen spawnen, Backspace & Co. ignorieren
      if (e.inputType === "insertText" && e.data) {
        spawnLetter(e.data[0]);
      }
    });
    // Optional: Enter drückt ein Leerzeichen-Spawn
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") { e.preventDefault(); spawnLetter("•"); }
    });

    // ----- Rendering: Text über die Physik zeichnen -----
    Events.on(render, "afterRender", () => {
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      // leichte Schattierung für bessere Lesbarkeit
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 1;

      letters.forEach(({ body, char, size }) => {
        const { x, y } = body.position;
        ctx.translate(x, y);
        ctx.rotate(body.angle);
        // Gewicht "600" visuell – Canvas-Font-String: "bold 100px 'MontserratVar'"
        ctx.font = `600 ${size}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
        ctx.fillStyle = "#222";
        ctx.fillText(char, 0, 0);
        ctx.rotate(-body.angle);
        ctx.translate(-x, -y);
      });

      ctx.restore();
    });

    // ----- Gyroskop: Permission-Button für iOS + Live-Gravity -----
    const gyroBtn = document.getElementById("gyroBtn");

    async function enableGyro() {
      try {
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== "granted") { alert("Bitte Bewegungszugriff erlauben."); return; }
        }
        window.addEventListener("deviceorientation", (ev) => {
          // gamma: links/rechts, beta: vor/zurück
          const gx = (ev.gamma || 0) / 18; // stärkere Reaktion
          const gy = (ev.beta  || 0) / 18;
          engine.world.gravity.x = Math.max(-2, Math.min(2, gx));
          engine.world.gravity.y = Math.max(-2, Math.min(2, gy));
        }, { passive: true });
        gyroBtn.textContent = "Gyro aktiv";
        gyroBtn.disabled = true;
      } catch (e) {
        console.error(e);
        alert("Gyro konnte nicht aktiviert werden.");
      }
    }
    gyroBtn.addEventListener("click", enableGyro);

    // Erstes Resize korrekt setzen
    resize();
  </script>
</body>
</html>

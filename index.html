<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Gyro Typo Playground</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; width:100vw; height:100vh; }
    #ui {
      position: fixed; inset:auto 0 0 0; display:flex; gap:8px;
      padding:10px; background:linear-gradient(to top, rgba(250,250,250,0.95), rgba(250,250,250,0.6));
      align-items:center; backdrop-filter:saturate(1.1) blur(6px);
    }
    #input { flex:1; font-size:16px; padding:10px 12px; border-radius:12px; border:1px solid #ddd; }
    #gyroBtn { padding:10px 12px; border-radius:12px; border:1px solid #ddd; background:#fff; }

    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
    .use-montserrat { font-family:"MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <div id="ui" class="use-montserrat">
    <input id="input" type="text" placeholder="Tippe hier einzelne Buchstaben…" inputmode="latin" />
    <button id="gyroBtn" type="button">Gyro aktivieren</button>
  </div>

  <!-- poly-decomp -->
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <!-- opentype.js -->
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const { Engine, Render, Runner, World, Bodies, Vertices, Events, Body, Common } = Matter;

    // poly-decomp an Matter binden
    if (window.decomp && Common && Common.setDecomp) {
      Common.setDecomp(window.decomp);
    }

    // ----- Canvas + Engine -----
    const canvas = document.getElementById("world");
    const engine = Engine.create();
    engine.world.gravity.y = 1;
    const render = Render.create({
      canvas,
      engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "#fafafa",
        pixelRatio: window.devicePixelRatio
      }
    });
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // Resize
    let walls = null;
    function makeWalls() {
      const w = render.options.width;
      const h = render.options.height;
      const t = 50;
      if (walls) World.remove(engine.world, walls);
      walls = Matter.Composite.create();
      Matter.Composite.add(walls, [
        Bodies.rectangle(w/2, h + t/2, w, t, { isStatic: true }),
        Bodies.rectangle(w/2, -t/2, w, t, { isStatic: true }),
        Bodies.rectangle(-t/2, h/2, t, h, { isStatic: true }),
        Bodies.rectangle(w + t/2, h/2, t, h, { isStatic: true })
      ]);
      World.add(engine.world, walls);
    }
    function resize() {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      makeWalls();
    }
    window.addEventListener("resize", resize);
    makeWalls();

    // ----- Font laden (lokal) mit Fallback -----
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf";
    const FALLBACK_TTF = "https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/montserrat/Montserrat-Regular.ttf";

    let font = null;
    function loadFont(url, cb){ opentype.load(url, (err, f) => cb(err, f)); }
    loadFont(LOCAL_FONT_URL, (err, f) => {
      if (!err && f) { font = f; console.log("Font (lokal) geladen ✔️"); }
      else {
        console.warn("Lokaler Font-Load fail, Fallback:", err);
        loadFont(FALLBACK_TTF, (e2, f2) => {
          if (!e2 && f2) { font = f2; console.log("Fallback-Font geladen ✔️"); }
          else console.error("Kein Font verfügbar:", e2);
        });
      }
    });

    // ----- Hilfen: Kurven-Sampling + RDP-Simplify -----
    function quadAt(p0, p1, p2, t) {
      const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
      const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
      return {x,y};
    }
    function cubicAt(p0,p1,p2,p3,t){
      const mt = 1-t;
      const x = mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x;
      const y = mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y;
      return {x,y};
    }
    // Ramer–Douglas–Peucker Simplify
    function rdp(points, epsilon) {
      if (points.length < 3) return points.slice();
      const dmax = (() => {
        const [p0, pn] = [points[0], points[points.length-1]];
        let idx = -1, maxDist = -1;
        for (let i=1; i<points.length-1; i++) {
          const d = pointLineDistance(points[i], p0, pn);
          if (d > maxDist) { idx = i; maxDist = d; }
        }
        return {idx, maxDist};
      })();
      if (dmax.maxDist > epsilon) {
        const rec1 = rdp(points.slice(0, dmax.idx+1), epsilon);
        const rec2 = rdp(points.slice(dmax.idx), epsilon);
        return rec1.slice(0, -1).concat(rec2);
      } else {
        return [points[0], points[points.length-1]];
      }
    }
    function pointLineDistance(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A*C + B*D;
      const lenSq = C*C + D*D || 1;
      let t = dot / lenSq; t = Math.max(0, Math.min(1, t));
      const x = a.x + t*C, y = a.y + t*D;
      const dx = p.x - x, dy = p.y - y;
      return Math.hypot(dx, dy);
    }

    // opentype-Pfad → Polygone (gesampelt + vereinfacht)
    function pathToPolygons(path) {
      const polys = [];
      let cur = [];
      let last = {x:0,y:0};
      const STEP_Q = 12; // höher = glatter
      const STEP_C = 18;

      path.commands.forEach(cmd => {
        if (cmd.type === "M") {
          if (cur.length) { polys.push(cur); cur = []; }
          last = { x: cmd.x, y: -cmd.y };
          cur.push(last);
        } else if (cmd.type === "L") {
          const p = { x: cmd.x, y: -cmd.y };
          cur.push(p);
          last = p;
        } else if (cmd.type === "Q") {
          const cp = { x: cmd.x1, y: -cmd.y1 };
          const p2 = { x: cmd.x,  y: -cmd.y  };
          for (let i = 1; i <= STEP_Q; i++) {
            const t = i/STEP_Q;
            cur.push(quadAt(last, cp, p2, t));
          }
          last = p2;
        } else if (cmd.type === "C") {
          const c1 = { x: cmd.x1, y: -cmd.y1 };
          const c2 = { x: cmd.x2, y: -cmd.y2 };
          const p3 = { x: cmd.x,  y: -cmd.y  };
          for (let i = 1; i <= STEP_C; i++) {
            const t = i/STEP_C;
            cur.push(cubicAt(last, c1, c2, p3, t));
          }
          last = p3;
        } else if (cmd.type === "Z") {
          if (cur.length) { polys.push(cur); cur = []; }
        }
      });
      if (cur.length) polys.push(cur);

      // Vereinfachen per RDP (Toleranz in Pixeln)
      const EPS = 0.8;
      return polys.map(poly => (poly.length > 3 ? rdp(poly, EPS) : poly));
    }

    // ----- Buchstaben-Verwaltung -----
    const letters = [];
    const LETTER_TTL_MS = 30000;

    function spawnLetter(char) {
      if (!font) return;

      const size = 100;
      const path = font.getPath(char, 0, 0, size);
      const polygons = pathToPolygons(path);
      if (!polygons.length) return;

      const body = Bodies.fromVertices(
        render.options.width / 2,
        Math.max(120, window.innerHeight * 0.2),
        polygons,
        {
          friction: 0.85,
          frictionStatic: 1.0,
          frictionAir: 0.01,
          restitution: 0.18,
          render: { fillStyle: "#00000000" }
        },
        true
      );
      if (!body) return;

      // Masse ≈ Fläche (grobe Annäherung)
      try {
        const flat = polygons.flat();
        const hull = Vertices.hull(flat);
        const area = Math.abs(Vertices.area(hull));
        if (area && isFinite(area)) Body.setMass(body, Math.max(1, area / 1500));
      } catch {}

      World.add(engine.world, body);

      const rec = { body, char, size, born: performance.now() };
      letters.push(rec);

      setTimeout(() => {
        World.remove(engine.world, body);
        const idx = letters.indexOf(rec);
        if (idx >= 0) letters.splice(idx, 1);
      }, LETTER_TTL_MS);
    }

    // ----- Eingabe -----
    const input = document.getElementById("input");
    input.addEventListener("beforeinput", (e) => {
      if (e.inputType === "insertText" && e.data) {
        spawnLetter(e.data[0]);
      }
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") { e.preventDefault(); spawnLetter("•"); }
    });

    // ----- Rendering (sichtbare Schrift) -----
    Events.on(render, "afterRender", () => {
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 1;

      for (const { body, char, size } of letters) {
        const { x, y } = body.position;
        ctx.translate(x, y);
        ctx.rotate(body.angle);
        ctx.font = `600 ${size}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
        ctx.fillStyle = "#222";
        ctx.fillText(char, 0, 0);
        ctx.rotate(-body.angle);
        ctx.translate(-x, -y);
      }
      ctx.restore();
    });

    // ----- Gyro -----
    const gyroBtn = document.getElementById("gyroBtn");
    async function enableGyro() {
      try {
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== "granted") { alert("Bitte Bewegungszugriff erlauben."); return; }
        }
        window.addEventListener("deviceorientation", (ev) => {
          const gx = (ev.gamma || 0) / 18;
          const gy = (ev.beta  || 0) / 18;
          engine.world.gravity.x = Math.max(-2, Math.min(2, gx));
          engine.world.gravity.y = Math.max(-2, Math.min(2, gy));
        }, { passive: true });
        gyroBtn.textContent = "Gyro aktiv";
        gyroBtn.disabled = true;
      } catch (e) {
        console.error(e);
        alert("Gyro konnte nicht aktiviert werden.");
      }
    }
    gyroBtn.addEventListener("click", enableGyro);

    // initial
    resize();
  </script>
</body>
</html>

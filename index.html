<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Gyro Typo Playground</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; } /* Größe setzen wir per JS exakt */
    #ui {
      position: fixed; left:0; right:0; bottom:0;
      display:flex; gap:8px; padding:10px;
      background:linear-gradient(to top, rgba(250,250,250,0.95), rgba(250,250,250,0.6));
      align-items:center; backdrop-filter:saturate(1.1) blur(6px);
      z-index:10;
    }
    #input { flex:1; font-size:16px; padding:10px 12px; border-radius:12px; border:1px solid #ddd; }
    #gyroBtn { padding:10px 12px; border-radius:12px; border:1px solid #ddd; background:#fff; }

    /* Deine Schrift – stelle sicher, dass die URL unten erreichbar ist */
    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
    .use-montserrat { font-family:"MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <div id="ui" class="use-montserrat">
    <input id="input" type="text" placeholder="Tippe hier einzelne Buchstaben…" inputmode="latin" />
    <button id="gyroBtn" type="button">Gyro aktivieren</button>
  </div>

  <!-- poly-decomp -->
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <!-- opentype.js -->
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const { Engine, Render, Runner, World, Bodies, Vertices, Events, Body, Common, Query, Bounds, Composite } = Matter;

    // poly-decomp an Matter binden
    if (window.decomp && Common && Common.setDecomp) {
      Common.setDecomp(window.decomp);
    }

    const canvas = document.getElementById("world");
    const ui = document.getElementById("ui");
    const input = document.getElementById("input");
    const gyroBtn = document.getElementById("gyroBtn");

    // DPI-korrektes Canvas
    function sizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const cssW = document.documentElement.clientWidth;
      const cssH = document.documentElement.clientHeight;
      const pxW = Math.floor(cssW * dpr), pxH = Math.floor(cssH * dpr);
      if (canvas.width !== pxW || canvas.height !== pxH) {
        canvas.width = pxW; canvas.height = pxH;
      }
      render.options.width = cssW;
      render.options.height = cssH;
      render.canvas.style.width = cssW + "px";
      render.canvas.style.height = cssH + "px";
    }

    // Engine & Render
    const engine = Engine.create();
    engine.world.gravity.y = 1; // Basisgravitation
    const render = Render.create({
      canvas,
      engine,
      options: {
        width: 0, height: 0,
        wireframes: false,
        background: "#fafafa",
        pixelRatio: 1 // wir skalieren selbst
      }
    });
    sizeCanvasToDisplaySize();
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // Wände
    let wallsComposite = null;
    const WALL_THICK = 50;
    function rebuildWalls() {
      if (wallsComposite) World.remove(engine.world, wallsComposite);
      const w = render.options.width, h = render.options.height, t = WALL_THICK;
      wallsComposite = Matter.Composite.create();
      Matter.Composite.add(wallsComposite, [
        Bodies.rectangle(w/2, h + t/2, w, t, { isStatic: true }),
        Bodies.rectangle(w/2, -t/2, w, t, { isStatic: true }),
        Bodies.rectangle(-t/2, h/2, t, h, { isStatic: true }),
        Bodies.rectangle(w + t/2, h/2, t, h, { isStatic: true })
      ]);
      World.add(engine.world, wallsComposite);
    }
    rebuildWalls();

    // Font laden (opentype für Physik + Canvas-Font für Sichtbarkeit)
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf"; // <- passe das an DEINEN Pfad an
    const FALLBACK_TTF = ""; // optionaler zweiter TTF-Host (mit CORS), sonst leer lassen

    let fontOT = null;          // opentype Font
    let canvasFontReady = false;

    function loadOTFont(url) {
      return new Promise((resolve, reject) => {
        if (!url) return reject(new Error("No URL"));
        opentype.load(url, (err, f) => err ? reject(err) : resolve(f));
      });
    }

    (async () => {
      try {
        fontOT = await loadOTFont(LOCAL_FONT_URL);
        console.log("opentype Font geladen ✔️");
      } catch (e) {
        console.warn("Lokaler opentype-Load fehlgeschlagen:", e);
        if (FALLBACK_TTF) {
          try {
            fontOT = await loadOTFont(FALLBACK_TTF);
            console.log("Fallback opentype Font geladen ✔️");
          } catch (e2) {
            console.error("Kein opentype Font verfügbar:", e2);
          }
        }
      }
    })();

    (async () => {
      try { await Promise.race([document.fonts.load('600 100px "MontserratVar"'), new Promise(r=>setTimeout(r,1500))]); } catch {}
      try { await document.fonts.ready; } catch {}
      canvasFontReady = true;
    })();

    // Kurven-Sampling & RDP-Simplify
    function quadAt(p0, p1, p2, t) {
      const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
      const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
      return {x,y};
    }
    function cubicAt(p0,p1,p2,p3,t){
      const mt = 1-t;
      const x = mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x;
      const y = mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y;
      return {x,y};
    }
    function pointLineDistance(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A*C + B*D;
      const lenSq = C*C + D*D || 1;
      let t = dot / lenSq; t = Math.max(0, Math.min(1, t));
      const x = a.x + t*C, y = a.y + t*D;
      return Math.hypot(p.x - x, p.y - y);
    }
    function rdp(points, epsilon) {
      if (points.length < 3) return points.slice();
      let idx = -1, maxDist = -1;
      for (let i=1;i<points.length-1;i++){
        const d = pointLineDistance(points[i], points[0], points[points.length-1]);
        if (d > maxDist) { idx = i; maxDist = d; }
      }
      if (maxDist > epsilon) {
        const left = rdp(points.slice(0, idx+1), epsilon);
        const right = rdp(points.slice(idx), epsilon);
        return left.slice(0, -1).concat(right);
      }
      return [points[0], points[points.length-1]];
    }

    function pathToPolygons(path) {
      const polys = [];
      let cur = [];
      let last = {x:0,y:0};
      const STEP_Q = 12, STEP_C = 18;

      path.commands.forEach(cmd => {
        if (cmd.type === "M") {
          if (cur.length) { polys.push(cur); cur = []; }
          last = { x: cmd.x, y: -cmd.y };
          cur.push(last);
        } else if (cmd.type === "L") {
          const p = { x: cmd.x, y: -cmd.y };
          cur.push(p); last = p;
        } else if (cmd.type === "Q") {
          const cp = { x: cmd.x1, y: -cmd.y1 };
          const p2 = { x: cmd.x,  y: -cmd.y };
          for (let i=1;i<=STEP_Q;i++) cur.push(quadAt(last, cp, p2, i/STEP_Q));
          last = p2;
        } else if (cmd.type === "C") {
          const c1 = { x: cmd.x1, y: -cmd.y1 };
          const c2 = { x: cmd.x2, y: -cmd.y2 };
          const p3 = { x: cmd.x,  y: -cmd.y };
          for (let i=1;i<=STEP_C;i++) cur.push(cubicAt(last, c1, c2, p3, i/STEP_C));
          last = p3;
        } else if (cmd.type === "Z") {
          if (cur.length) { polys.push(cur); cur = []; }
        }
      });
      if (cur.length) polys.push(cur);

      const EPS = 0.8; // px
      return polys.map(poly => (poly.length > 3 ? rdp(poly, EPS) : poly));
    }

    // Spawn-Helfer
    function polygonsBounds(polys) {
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      polys.forEach(poly => {
        poly.forEach(p => {
          if (p.x < minX) minX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.x > maxX) maxX = p.x;
          if (p.y > maxY) maxY = p.y;
        });
      });
      return { min:{x:minX,y:minY}, max:{x:maxX,y:maxY}, width:maxX-minX, height:maxY-minY };
    }

    function canSpawnAt(x, y, width, height) {
      const margin = 6; // Puffer
      const region = {
        min: { x: x - width/2 - margin, y: y - height/2 - margin },
        max: { x: x + width/2 + margin, y: y + height/2 + margin }
      };
      const bodies = Composite.allBodies(engine.world);
      const hits = Query.region(bodies, region);
      // blockieren, wenn irgendein echter Körper (nicht Sensor) im Startbereich liegt
      return !hits.some(b => !b.isSensor);
    }

    const letters = [];
    const LETTER_TTL_MS = 30000;

    function spawnLetter(char) {
      if (!fontOT) return; // Font noch nicht bereit

      const size = 100;
      const path = fontOT.getPath(char, 0, 0, size);
      const polys = pathToPolygons(path);
      if (!polys.length) return;

      // Zielposition: echte Mitte, aber so geklemmt, dass der Buchstabe komplett innerhalb der Wände bleibt
      const w = render.options.width, h = render.options.height;
      const bounds = polygonsBounds(polys);
      const safeInset = WALL_THICK + 8;
      let spawnX = Math.max(safeInset + bounds.width/2, Math.min(w - safeInset - bounds.width/2, w/2));
      const uiH = ui.getBoundingClientRect().height || 0;
      let spawnY = Math.max(safeInset + bounds.height/2, Math.min(h - uiH - safeInset - bounds.height/2, h/2));

      // Wenn Bereich belegt, NICHT spawnen (=> "nicht weiterschreiben")
      if (!canSpawnAt(spawnX, spawnY, bounds.width, bounds.height)) {
        input.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}], {duration:180});
        return;
      }

      const body = Bodies.fromVertices(
        spawnX, spawnY, polys,
        {
          friction: 0.9,
          frictionStatic: 1.0,
          frictionAir: 0.01,
          restitution: 0.12,
          render: { fillStyle: "#00000000" } // wir malen Text selbst
        },
        true
      );
      if (!body) return;

      // Masse ≈ Fläche (grobe Annäherung über konvexe Hülle)
      try {
        const flat = polys.flat();
        const hull = Vertices.hull(flat);
        const area = Math.abs(Vertices.area(hull));
        if (area && isFinite(area)) Body.setMass(body, Math.max(1, area / 1500));
      } catch {}

      World.add(engine.world, body);

      const rec = { body, char, size, born: performance.now() };
      letters.push(rec);

      setTimeout(() => {
        World.remove(engine.world, body);
        const idx = letters.indexOf(rec);
        if (idx >= 0) letters.splice(idx, 1);
      }, LETTER_TTL_MS);
    }

    // Eingabe (einzelne Zeichen)
    input.addEventListener("beforeinput", (e) => {
      if (e.inputType === "insertText" && e.data) {
        e.preventDefault(); // wir verwalten das Spawnen
        spawnLetter(e.data[0]);
      }
    });

    // Sichtbares Text-Rendering (Canvas)
    Events.on(render, "afterRender", () => {
      if (!canvasFontReady) return;
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 1;

      for (const { body, char, size } of letters) {
        const { x, y } = body.position;
        ctx.translate(x, y);
        ctx.rotate(body.angle);
        ctx.font = `600 ${size}px "MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
        ctx.fillStyle = "#222";
        ctx.fillText(char, 0, 0);
        ctx.rotate(-body.angle);
        ctx.translate(-x, -y);
      }
      ctx.restore();
    });

    // Gyro mit Desktop-Fallback (nur echte Sensorwerte verwenden)
    let gyroActive = false;
    gyroBtn.addEventListener("click", async () => {
      try {
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== "granted") { alert("Bitte Bewegungszugriff erlauben."); return; }
        }
        gyroActive = true;
        let lastUpdate = performance.now();
        window.addEventListener("deviceorientation", (ev) => {
          const hasData = (typeof ev.beta === "number" && !isNaN(ev.beta)) ||
                          (typeof ev.gamma === "number" && !isNaN(ev.gamma));
          if (hasData) {
            const gx = (ev.gamma || 0) / 18;
            const gy = (ev.beta  || 0) / 18;
            engine.world.gravity.x = Math.max(-2, Math.min(2, gx));
            engine.world.gravity.y = Math.max(-2, Math.min(2, gy));
            lastUpdate = performance.now();
          } else {
            // Keine Daten → nach 1s sanft auf Default
            if (performance.now() - lastUpdate > 1000) {
              engine.world.gravity.x = 0;
              engine.world.gravity.y = 1;
            }
          }
        }, { passive: true });
        gyroBtn.textContent = "Gyro aktiv";
        gyroBtn.disabled = true;
      } catch (e) {
        console.error(e);
        alert("Gyro konnte nicht aktiviert werden.");
      }
    });

    // Resize-Handling
    function onResize() {
      sizeCanvasToDisplaySize();
      rebuildWalls();
    }
    window.addEventListener("resize", onResize);
    onResize();
  </script>
</body>
</html>

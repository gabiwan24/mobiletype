<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Typo Voice Physics</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fafafa; }
    canvas { display:block; touch-action:none; }

    @font-face {
      font-family: "MontserratVar";
      src: url("fonts/Montserrat-VariableFont_wght.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <script>
    const {
      Engine, Render, Runner, World, Bodies, Body, Composite,
      Common, Events, Vertices, Query
    } = Matter;

    // ---- Globals ----
    const WALL_THICK = 60;
    let walls = null;
    const MIC_R = 120;   // Ø 240
    let micBody = null;

    if (window.decomp && Common && Common.setDecomp) Common.setDecomp(window.decomp);

    // ---- Engine / Render ----
    const canvas = document.getElementById('world');
    const engine = Engine.create({ enableSleeping: true });
    engine.world.gravity.y = 1;
    engine.positionIterations = 10;
    engine.velocityIterations = 10;
    engine.constraintIterations = 2;

    const render = Render.create({
      canvas, engine,
      options: { width: 0, height: 0, wireframes: false, background: "#fafafa", pixelRatio: 1 }
    });

    function resize() {
      const w = document.documentElement.clientWidth;
      const h = document.documentElement.clientHeight;
      if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
      render.options.width = w; render.options.height = h;
      render.canvas.style.width = w + "px"; render.canvas.style.height = h + "px";
      buildWalls();
      placeMic();
    }
    window.addEventListener('resize', resize);
    Render.run(render);
    Runner.run(Runner.create(), engine);
    resize();

    // ---- Walls ----
    function buildWalls() {
      if (walls) World.remove(engine.world, walls);
      const w = render.options.width, h = render.options.height, t = WALL_THICK;
      walls = Composite.create();
      const stat = { isStatic: true, friction: 1, restitution: 0.02, render: { visible: false } };
      Composite.add(walls, [
        Bodies.rectangle(w/2, h + t/2, w, t, stat),
        Bodies.rectangle(w/2, -t/2, w, t, stat),
        Bodies.rectangle(-t/2, h/2, t, h, stat),
        Bodies.rectangle(w + t/2, h/2, t, h, stat)
      ]);
      World.add(engine.world, walls);
    }

    // ---- Mic button ----
    function placeMic() {
      if (micBody) World.remove(engine.world, micBody);
      const w = render.options.width, h = render.options.height;
      micBody = Bodies.circle(w/2, h - MIC_R - 20, MIC_R, {
        isStatic: true, friction: 1, frictionStatic: 1, restitution: 0.02,
        render: { visible: false }
      });
      World.add(engine.world, micBody);
    }

    // ---- Font ----
    const LOCAL_FONT_URL = "fonts/Montserrat-VariableFont_wght.ttf"; // anpassen
    let fontOT = null;
    let canvasFontReady = false; // wir zeichnen trotzdem (Fallback), setzen es später true

    function loadOTFont(url){ return new Promise((res,rej)=>opentype.load(url,(e,f)=>e?rej(e):res(f))); }
    (async()=>{ try{ fontOT = await loadOTFont(LOCAL_FONT_URL); } catch(e){ console.error("Font load fail:", e); } })();
    (async()=>{ try{ await Promise.race([document.fonts.load('700 120px "MontserratVar"'), new Promise(r=>setTimeout(r,1200))]); }catch{} try{ await document.fonts.ready; }catch{} canvasFontReady = true; })();

    // ---- Path sampling + simplify ----
    function quadAt(p0,p1,p2,t){ return { x:(1-t)*(1-t)*p0.x+2*(1-t)*t*p1.x+t*t*p2.x, y:(1-t)*(1-t)*p0.y+2*(1-t)*t*p1.y+t*t*p2.y }; }
    function cubicAt(p0,p1,p2,p3,t){ const mt=1-t; return { x: mt*mt*mt*p0.x+3*mt*mt*t*p1.x+3*mt*t*t*p2.x+t*t*t*p3.x, y: mt*mt*mt*p0.y+3*mt*mt*t*p1.y+3*mt*t*t*p2.y+t*t*t*p3.y }; }
    function pointLineDistance(p,a,b){ const A=p.x-a.x,B=p.y-a.y,C=b.x-a.x,D=b.y-a.y; const dot=A*C+B*D,len=C*C+D*D||1; let t=dot/len; t=Math.max(0,Math.min(1,t)); const x=a.x+t*C,y=a.y+t*D; return Math.hypot(p.x-x,p.y-y); }
    function rdp(points, eps){ if(points.length<3) return points.slice(); let idx=-1,max=-1; for(let i=1;i<points.length-1;i++){ const d=pointLineDistance(points[i],points[0],points[points.length-1]); if(d>max){max=d;idx=i;} } if(max>eps){ const a=rdp(points.slice(0,idx+1),eps), b=rdp(points.slice(idx),eps); return a.slice(0,-1).concat(b);} return [points[0],points[points.length-1]];}
    function pathToPolygons(path){
      const polys=[]; let cur=[]; let last={x:0,y:0}; const STEP_Q=10, STEP_C=16;
      path.commands.forEach(cmd=>{
        if(cmd.type==="M"){ if(cur.length){polys.push(cur); cur=[];} last={x:cmd.x,y:-cmd.y}; cur.push(last); }
        else if(cmd.type==="L"){ const p={x:cmd.x,y:-cmd.y}; cur.push(p); last=p; }
        else if(cmd.type==="Q"){ const cp={x:cmd.x1,y:-cmd.y1}, p2={x:cmd.x,y:-cmd.y}; for(let i=1;i<=STEP_Q;i++) cur.push(quadAt(last,cp,p2,i/STEP_Q)); last=p2; }
        else if(cmd.type==="C"){ const c1={x:cmd.x1,y:-cmd.y1}, c2={x:cmd.x2,y:-cmd.y2}, p3={x:cmd.x,y:-cmd.y}; for(let i=1;i<=STEP_C;i++) cur.push(cubicAt(last,c1,c2,p3,i/STEP_C)); last=p3; }
        else if(cmd.type==="Z"){ if(cur.length){polys.push(cur); cur=[];} }
      });
      if(cur.length) polys.push(cur);
      const EPS=0.8; return polys.map(poly=> poly.length>3 ? rdp(poly,EPS):poly);
    }

    // ---- Loudness → weight ----
    let isRecording = false;
    let currentLine = "";           // live line shown
    let currentWght = 400;          // 100..800 (live)
    let peakRMS = 0;
    let sumRMS = 0, samplesRMS = 0;
    let audioCtx=null, analyser=null, mediaStream=null;

    function startAudioMeter() {
      return navigator.mediaDevices.getUserMedia({ audio: true }).then(stream=>{
        mediaStream = stream;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
        src.connect(analyser);
        tickVolume();
      });
    }
    function stopAudioMeter() {
      if (mediaStream) { mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
      if (audioCtx) { audioCtx.close().catch(()=>{}); audioCtx=null; }
      analyser = null;
    }
    function tickVolume() {
      if (!analyser) return;
      const buf = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(buf);
      let sum = 0; for (let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; }
      const rms = Math.sqrt(sum / buf.length);
      peakRMS = Math.max(peakRMS, rms);
      sumRMS += rms; samplesRMS++;
      const v = Math.min(1, rms * 8);
      currentWght = Math.round(100 + (800-100) * v);
      requestAnimationFrame(tickVolume);
    }
    function averagedWght() {
      const avg = samplesRMS ? (sumRMS / samplesRMS) : 0;
      const v = Math.min(1, avg * 8);
      return Math.round(100 + (800-100) * v);
    }

    // ---- SpeechRecognition (press & hold) + gyro ----
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    let gyroInited = false;
    function initGyroOnce() {
      if (gyroInited) return;
      gyroInited = true;
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().catch(()=>{}).finally(attachGyro);
      } else attachGyro();
    }
    function attachGyro() {
      window.addEventListener("deviceorientation", (ev) => {
        const gx = (typeof ev.gamma === "number") ? ev.gamma/18 : 0;
        const gy = (typeof ev.beta  === "number") ? ev.beta/18  : 1;
        engine.world.gravity.x = Math.max(-2, Math.min(2, gx));
        engine.world.gravity.y = Math.max(-2, Math.min(2, gy));
      }, { passive: true });
    }

    function startSpeech() {
      if (!SR) { alert("Spracherkennung wird nicht unterstützt."); return; }
      if (isRecording) return;
      initGyroOnce();

      recognition = new SR();
      recognition.lang = "de-DE";
      recognition.interimResults = true;
      recognition.continuous = true;

      currentLine = ""; peakRMS = 0; sumRMS = 0; samplesRMS = 0; currentWght = 400;

      recognition.onresult = (e) => {
        let finalText = "";
        for (let i=e.resultIndex; i<e.results.length; i++){
          const res = e.results[i];
          if (res.isFinal) finalText += res[0].transcript;
          else currentLine = res[0].transcript;
        }
        if (finalText.trim()) currentLine = finalText.trim();
      };
      recognition.onend   = () => { isRecording = false; finalizePress(); };
      recognition.onerror = () => { isRecording = false; finalizePress(); };

      startAudioMeter().then(()=>{
        try { recognition.start(); isRecording = true; } catch(e){ console.error(e); isRecording=false; }
      }).catch(err=> console.error(err));
    }
    function stopSpeech() {
      try { recognition && recognition.stop(); } catch{}
      stopAudioMeter();
    }

    // ---- Spawn falling word (independent letters) ----
    const LETTER_TTL_MS = 30000;
    const letterGroups = [];

    function measureWord(word, size) {
      const scale = size / fontOT.unitsPerEm;
      const glyphs = fontOT.stringToGlyphs(word);
      let width = 0;
      for (let i=0;i<glyphs.length;i++){
        const g = glyphs[i];
        width += g.advanceWidth * scale;
        if (i < glyphs.length - 1) width += fontOT.getKerningValue(g, glyphs[i+1]) * scale;
      }
      return { glyphs, width, scale };
    }

    function spawnFallingWord(word, size, wght, volumePeak) {
      if (!fontOT) return;
      word = word.trim(); if (!word) return;

      const { glyphs, width } = measureWord(word, size);
      const w = render.options.width, h = render.options.height;
      const inset = WALL_THICK + 8;
      const spawnX = Math.max(inset + width/2, Math.min(w - inset - width/2, w/2));
      const spawnY = Math.max(inset + size/2, Math.min(h - inset - size/2 - (MIC_R + 24), h/2));

      const letters = [];
      let penX = -width/2;

      const EXTRA_SPACING = 2; // kleiner zusätzlicher Abstand verhindert Anfangs-Überlappungen
      const chars = Array.from(word);

      for (let i=0;i<glyphs.length;i++){
        const g = glyphs[i];
        const path = g.getPath(0, 0, size);
        const polys = pathToPolygons(path);

        const scale = size / fontOT.unitsPerEm;
        const adv = (g.advanceWidth * scale)
                  + (i<glyphs.length-1 ? fontOT.getKerningValue(g, glyphs[i+1]) * scale : 0)
                  + EXTRA_SPACING;

        if (polys.length){
          const shifted = polys.map(poly => poly.map(p => ({ x: p.x + penX, y: p.y })));
          const body = Bodies.fromVertices(spawnX, spawnY, shifted, {
            friction: 0.2,          // ↓ Reibung -> weniger Kleben
            frictionStatic: 0.05,   // ↓ statische Reibung
            frictionAir: 0.03,      // leicht dämpfen
            restitution: 0.18,      // etwas Bounciness -> stößt ab
            render: { visible: false },
            sleepThreshold: 40
          }, true);
          if (body){
            // Masse
            try {
              const flat = shifted.flat();
              const hull = Vertices.hull(flat);
              const area = Math.abs(Vertices.area(hull));
              const loudFactor = 0.7 + 0.6 * Math.min(1, volumePeak * 6);
              const randFactor  = 0.8 + Math.random()*0.5;
              const mass = Math.max(1, (area/1600) * loudFactor * randFactor);
              Body.setMass(body, mass);
            } catch {}
            Body.setAngularVelocity(body, (Math.random()*2-1) * 0.35);
            // minimales Jitter, um perfekte Kantenkontakte zu vermeiden
            Body.setPosition(body, { x: body.position.x, y: body.position.y + (Math.random()-0.5)*0.5 });
            body.label = "char:" + (chars[i] || " ");
            body.plugin = { letter: true };
            letters.push({ body, char: (chars[i] || " "), size, wght });
            Composite.add(engine.world, body);
          }
        }
        penX += (isFinite(adv) ? adv : 0);
      }

      const group = { letters };
      letterGroups.push(group);
      setTimeout(()=>{
        for (const L of group.letters) Composite.remove(engine.world, L.body);
        const idx = letterGroups.indexOf(group); if (idx>=0) letterGroups.splice(idx,1);
      }, LETTER_TTL_MS);
    }

    function finalizePress() {
      const line = (currentLine || "").trim();
      currentLine = "";
      const size = 100;
      const wght = averagedWght();   // Wortgewicht = Durchschnittslautstärke
      const peak = peakRMS;
      stopAudioMeter();
      if (!line) return;
      line.split(/\s+/).forEach(w => spawnFallingWord(w, size, wght, peak));
    }

    // ---- Repulsion on contact (gegen Klumpen) ----
    // Bei aktiver Kollision stoßen wir Buchstaben leicht auseinander.
    Events.on(engine, "collisionActive", (evt) => {
      const kBase = 0.0008; // Stärke der Abstoßkraft
      for (const pair of evt.pairs) {
        const A = pair.bodyA, B = pair.bodyB;
        // nur zwischen dynamischen Buchstaben
        if (!(A.plugin && A.plugin.letter) || !(B.plugin && B.plugin.letter)) continue;

        // Normal zeigt von B -> A (Matter), nutzen wir zum Auseinanderdrücken
        const n = pair.collision.normal;
        // pair.separation ist in Matter < 0 bei Überlappung; wir nehmen die Tiefe
        const depth = Math.max(0, -pair.separation || 0);
        const k = kBase * (1 + depth);

        Body.applyForce(A, A.position, { x:  n.x * k, y:  n.y * k });
        Body.applyForce(B, B.position, { x: -n.x * k, y: -n.y * k });
      }
    });

    // ---- Rendering ----
    Events.on(render, "afterRender", () => {
      const ctx = render.context;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      // Live-Zeile (zeige IMMER: auch wenn Font noch lädt -> Fallback-Font verfügbar)
      if (isRecording || currentLine) {
        const w = render.options.width, h = render.options.height;
        const inset = WALL_THICK + 8;
        const fontSize = 120;
        // MontserratVar wenn ready, sonst System-Font; dadurch sieht man auf Mobile sofort Text
        const fam = canvasFontReady ? '"MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial' : 'system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.font = `${currentWght} ${fontSize}px ${fam}`;
        const text = currentLine || "";
        const tw = ctx.measureText(text).width;
        const x = Math.max(inset + tw/2, Math.min(w - inset - tw/2, w/2));
        const y = Math.max(inset + fontSize, Math.min(h - inset - (MIC_R + 24), h/2));
        ctx.fillStyle = "#222";
        ctx.shadowColor = "rgba(0,0,0,0.20)"; ctx.shadowBlur = 6; ctx.shadowOffsetY = 1;
        ctx.fillText(text, x, y);
      }

      // Gefallene Buchstaben
      {
        const famFall = canvasFontReady ? '"MontserratVar", system-ui, -apple-system, Segoe UI, Roboto, Arial' : 'system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.shadowColor = "rgba(0,0,0,0.20)"; ctx.shadowBlur = 6; ctx.shadowOffsetY = 1;
        for (const group of letterGroups) {
          for (const L of group.letters) {
            const { body, char, size, wght } = L;
            const { x, y } = body.position;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(body.angle);
            ctx.font = `${wght} ${size}px ${famFall}`;
            ctx.fillStyle = "#222";
            ctx.fillText(char, 0, size*0.35);
            ctx.restore();
          }
        }
      }

      // Mic-Button (schwarzer Kreis, ohne Icon)
      if (micBody) {
        const { x, y } = micBody.position;
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath(); ctx.arc(0, 0, MIC_R, 0, Math.PI*2); ctx.closePath();
        ctx.fillStyle = "#000"; ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    });

    // ---- Pointer: press & hold ----
    function hitMic(evt) {
      if (!micBody) return false;
      const rect = canvas.getBoundingClientRect();
      const cx = (evt.clientX ?? (evt.touches && evt.touches[0]?.clientX)) - rect.left;
      const cy = (evt.clientY ?? (evt.touches && evt.touches[0]?.clientY)) - rect.top;
      const dx = cx - micBody.position.x, dy = cy - micBody.position.y;
      return (dx*dx + dy*dy) <= (MIC_R*MIC_R);
    }
    canvas.addEventListener('pointerdown', (e)=>{
      if (hitMic(e)) {
        e.preventDefault(); canvas.setPointerCapture?.(e.pointerId);
        startSpeech();
      }
    });
    canvas.addEventListener('pointerup', (e)=>{
      if (isRecording) { e.preventDefault(); stopSpeech(); }
    });
    canvas.addEventListener('pointercancel', ()=> { if (isRecording) stopSpeech(); });
    window.addEventListener('blur', ()=> { if (isRecording) stopSpeech(); });

  </script>
</body>
</html>
